// Generated by CoffeeScript 1.3.3
(function() {
  var $, D2R, PI2, R2D, SCALE, S_T_A_R_T_E_D, b2AABB, b2Body, b2BodyDef, b2CircleShape, b2DebugDraw, b2Fixture, b2FixtureDef, b2MassData, b2MouseJointDef, b2PolygonShape, b2RevoluteJointDef, b2Vec2, b2World, createBox, createDOMObjects, downHandler, drawDOMObjects, getBodyAtMouse, getBodyCB, getElementPosition, hw, init, interval, isMouseDown, mouseJoint, mousePVec, mouseX, mouseY, moveHandler, selectedBody, upHandler, update, updateMouseDrag, world, x_velocity, y_velocity;

  b2Vec2 = Box2D.Common.Math.b2Vec2;

  b2AABB = Box2D.Collision.b2AABB;

  b2BodyDef = Box2D.Dynamics.b2BodyDef;

  b2Body = Box2D.Dynamics.b2Body;

  b2FixtureDef = Box2D.Dynamics.b2FixtureDef;

  b2Fixture = Box2D.Dynamics.b2Fixture;

  b2World = Box2D.Dynamics.b2World;

  b2MassData = Box2D.Collision.Shapes.b2MassData;

  b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;

  b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;

  b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;

  $ = jQuery;

  hw = {
    '-webkit-transform': 'translateZ(0)',
    '-moz-transform': 'translateZ(0)',
    '-o-transform': 'translateZ(0)',
    'transform': 'translateZ(0)'
  };

  S_T_A_R_T_E_D = false;

  world = {};

  x_velocity = 0;

  y_velocity = 0;

  SCALE = 30;

  D2R = Math.PI / 180;

  R2D = 180 / Math.PI;

  PI2 = Math.PI * 2;

  interval = {};

  mouseX = void 0;

  mouseY = void 0;

  mousePVec = void 0;

  isMouseDown = void 0;

  selectedBody = void 0;

  mouseJoint = void 0;

  downHandler = function(x, y) {
    isMouseDown = true;
    return moveHandler(x, y);
  };

  upHandler = function(x, y) {
    isMouseDown = false;
    mouseX = undefined;
    return mouseY = undefined;
  };

  moveHandler = function(x, y) {
    mouseX = x / 30;
    return mouseY = y / 30;
  };

  getBodyAtMouse = function() {
    var aabb;
    mousePVec = new b2Vec2(mouseX, mouseY);
    aabb = new b2AABB();
    aabb.lowerBound.Set(mouseX - 0.001, mouseY - 0.001);
    aabb.upperBound.Set(mouseX + 0.001, mouseY + 0.001);
    selectedBody = null;
    world.QueryAABB(getBodyCB, aabb);
    return selectedBody;
  };

  getBodyCB = function(fixture) {
    if (fixture.GetBody().GetType() !== b2Body.b2_staticBody) {
      if (fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
        selectedBody = fixture.GetBody();
        return false;
      }
    }
    return true;
  };

  getElementPosition = function(element) {
    var elem, tagname, x, y;
    elem = element;
    tagname = "";
    x = 0;
    y = 0;
    while ((typeof elem === "object") && (typeof elem.tagName !== "undefined")) {
      y += elem.offsetTop;
      x += elem.offsetLeft;
      tagname = elem.tagName.toUpperCase();
      if (tagname === "BODY") {
        elem = 0;
      }
      if (typeof elem === "object" ? typeof elem.offsetParent === "object" : void 0) {
        elem = elem.offsetParent;
      }
    }
    return {
      x: x,
      y: y
    };
  };

  updateMouseDrag = function() {
    var body, md;
    if (isMouseDown && (!mouseJoint)) {
      body = getBodyAtMouse();
      if (body) {
        md = new b2MouseJointDef();
        md.bodyA = world.GetGroundBody();
        md.bodyB = body;
        md.target.Set(mouseX, mouseY);
        md.collideConnected = true;
        md.maxForce = 300.0 * body.GetMass();
        mouseJoint = world.CreateJoint(md);
        body.SetAwake(true);
      }
    }
    if (mouseJoint) {
      if (isMouseDown) {
        return mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
      } else {
        world.DestroyJoint(mouseJoint);
        return mouseJoint = null;
      }
    }
  };

  createDOMObjects = function(jquery_selector) {
    return $(jquery_selector).each(function(a, b) {
      var body, domObj, domPos, height, width, x, y;
      console.log(a);
      console.log(b);
      domObj = $(b);
      domPos = $(b).position();
      width = domObj.width() / 2;
      height = domObj.height() / 2;
      x = domPos.left + width;
      y = domPos.top + height;
      body = createBox(x, y, width, height);
      body.m_userData = {
        domObj: domObj,
        width: width,
        height: height
      };
      domObj.css({
        left: "0px",
        top: "0px"
      });
      return true;
    });
  };

  createBox = function(x, y, width, height, static_) {
    var bodyDef, fixDef;
    bodyDef = new b2BodyDef;
    bodyDef.type = (static_ ? b2Body.b2_staticBody : b2Body.b2_dynamicBody);
    bodyDef.position.x = x / SCALE;
    bodyDef.position.y = y / SCALE;
    fixDef = new b2FixtureDef;
    fixDef.density = 1.5;
    fixDef.friction = 0.3;
    fixDef.restitution = 0.4;
    fixDef.shape = new b2PolygonShape;
    fixDef.shape.SetAsBox(width / SCALE, height / SCALE);
    return world.CreateBody(bodyDef).CreateFixture(fixDef);
  };

  drawDOMObjects = function() {
    var b, css, f, i, r, x, y, _results;
    i = 0;
    b = world.m_bodyList;
    _results = [];
    while (b) {
      f = b.m_fixtureList;
      while (f) {
        if (f.m_userData) {
          x = Math.floor((f.m_body.m_xf.position.x * SCALE) - f.m_userData.width);
          y = Math.floor((f.m_body.m_xf.position.y * SCALE) - f.m_userData.height);
          r = Math.round(((f.m_body.m_sweep.a + PI2) % PI2) * R2D * 100) / 100;
          css = {
            "-webkit-transform": "translate(" + x + "px," + y + "px) rotate(" + r + "deg)",
            "-moz-transform": "translate(" + x + "px," + y + "px) rotate(" + r + "deg)",
            "-ms-transform": "translate(" + x + "px," + y + "px) rotate(" + r + "deg)",
            "-o-transform": "translate(" + x + "px," + y + "px) rotate(" + r + "deg)",
            transform: "translate(" + x + "px," + y + "px) rotate(" + r + "deg)"
          };
          f.m_userData.domObj.css(css);
        }
        f = f.m_next;
      }
      _results.push(b = b.m_next);
    }
    return _results;
  };

  update = function() {
    updateMouseDrag();
    world.Step(1 / 60, 10, 10);
    drawDOMObjects();
    world.ClearForces();
    return requestAnimationFrame(update);
  };

  init = function(jquery_selector) {
    var h, mouse, w;
    S_T_A_R_T_E_D = true;
    world = new b2World(new b2Vec2(x_velocity, y_velocity), true);
    createDOMObjects($(jquery_selector).bodysnatch());
    w = $(window).width();
    h = $(window).height();
    createBox(0, -1, $(window).width(), 1, true);
    createBox($(window).width() + 1, 0, 1, $(window.document).height(), true);
    createBox(-1, 0, 1, $(window.document).height(), true);
    console.log($(window.document).height());
    console.log($(window).height());
    createBox(0, $(window.document).height() + 1, $(window).width(), 1, true);
    mouse = MouseAndTouch(document, downHandler, upHandler, moveHandler);
    return update();
  };

  $.fn.extend({
    physics: function(options) {
      var opts, self;
      self = $.fn.physics;
      opts = $.extend({}, self.default_options, options);
      x_velocity = opts['x-velocity'];
      y_velocity = opts['y-veloctiy'];
      if (S_T_A_R_T_E_D === false) {
        console.log('lets start');
        init(this.selector);
      } else {
        console.log('already started');
        createDOMObjects($(this.selector).bodysnatch());
      }
      return $(this).each(function(i, el) {
        self.init(el, opts);
        if (opts.log) {
          return self.log(el);
        }
      });
    }
  });

  $.extend($.fn.physics, {
    default_options: {
      'x-velocity': 0,
      'y-velocity': 0,
      log: true
    },
    init: function(el, opts) {},
    log: function(msg) {
      return console.log(msg);
    }
  });

  /*
  	fixDef = new b2FixtureDef()
  	fixDef.density = 1.0
  	fixDef.friction = 0.5
  	fixDef.restitution = 0.2
  
  	bodyDef = new b2BodyDef()
  	bodyDef.type = b2Body.b2_staticBody
  	fixDef.shape = new b2PolygonShape()
  	fixDef.shape.SetAsBox(20, 2) 
  	bodyDef.position.Set(10, 400 / 30 + 1.8)
  	world.CreateBody(bodyDef).CreateFixture(fixDef)
  	bodyDef.position.Set(10, -1.8)
  	world.CreateBody(bodyDef).CreateFixture(fixDef)
  	fixDef.shape.SetAsBox(2, 14)
  	bodyDef.position.Set(-1.8, 13)
  	world.CreateBody(bodyDef).CreateFixture(fixDef)
  	bodyDef.position.Set(21.8, 13)
  	world.CreateBody(bodyDef).CreateFixture(fixDef)
  
  	bodyDef.type = b2Body.b2_dynamicBody;
  	for i in [0..10]
  		fixDef.shape = new b2PolygonShape;
  		fixDef.shape.SetAsBox(Math.random() + 0.1, Math.random() + 0.1)
  		bodyDef.position.x = Math.random() * 10
  		bodyDef.position.y = Math.random() * 10
  		world.CreateBody(bodyDef).CreateFixture(fixDef)
  
  	window.setInterval(update, 1000 / 60)
  */


}).call(this);
